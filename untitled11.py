# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kFX9MaAOMcsb8KEwNWoBWY_c3NgOzCWg
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# CONFIGURACI√ìN DE LA P√ÅGINA
st.set_page_config(page_title="Iris Classification Project", layout="wide")

st.title("üå∏ Iris Species Classification - Final Project")
st.markdown("""
Este dashboard permite clasificar flores Iris utilizando un modelo de **Random Forest**.
El sistema predice la especie (Setosa, Versicolor, Virginica) bas√°ndose en las medidas ingresadas.
""")

#  1. CARGA Y PREPARACI√ìN DE DATOS
@st.cache_data
def load_data():
    iris = load_iris()
    df = pd.DataFrame(data=iris.data, columns=iris.feature_names)
    df['species'] = iris.target
    df['species_name'] = df['species'].map({0: 'setosa', 1: 'versicolor', 2: 'virginica'})
    return df, iris.target_names

df, target_names = load_data()

# Separaci√≥n de datos
X = df.drop(['species', 'species_name'], axis=1)
y = df['species']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 2. MODELADO (Random Forest)
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

# 3. PANEL LATERAL (User Input)
st.sidebar.header("üìè Ingresar Medidas")

def user_input_features():
    sepal_length = st.sidebar.slider('Sepal length (cm)', float(df.iloc[:,0].min()), float(df.iloc[:,0].max()), 5.4)
    sepal_width = st.sidebar.slider('Sepal width (cm)', float(df.iloc[:,1].min()), float(df.iloc[:,1].max()), 3.4)
    petal_length = st.sidebar.slider('Petal length (cm)', float(df.iloc[:,2].min()), float(df.iloc[:,2].max()), 1.3)
    petal_width = st.sidebar.slider('Petal width (cm)', float(df.iloc[:,3].min()), float(df.iloc[:,3].max()), 0.2)

    data = {'sepal length (cm)': sepal_length,
            'sepal width (cm)': sepal_width,
            'petal length (cm)': petal_length,
            'petal width (cm)': petal_width}
    return pd.DataFrame(data, index=[0])

input_df = user_input_features()

# 4. PREDICCI√ìN Y M√âTRICAS
prediction = model.predict(input_df)
prediction_proba = model.predict_proba(input_df)

col1, col2 = st.columns([2, 1])

with col1:
    st.subheader("üìä M√©tricas del Modelo")
    m1, m2, m3, m4 = st.columns(4)
    m1.metric("Accuracy", f"{accuracy_score(y_test, y_pred):.2f}")
    m2.metric("Precision", f"{precision_score(y_test, y_pred, average='macro'):.2f}")
    m3.metric("Recall", f"{recall_score(y_test, y_pred, average='macro'):.2f}")
    m4.metric("F1 Score", f"{f1_score(y_test, y_pred, average='macro'):.2f}")

    st.subheader("üîç Resultado")
    st.success(f"La flor es probablemente: **{target_names[prediction][0].upper()}**")
    st.write("Probabilidad por clase:")
    st.bar_chart(pd.DataFrame(prediction_proba, columns=target_names).T)

# VISUALIZACI√ìN 3D
with col2:
    st.subheader("üåê Visualizaci√≥n 3D")
    user_point = input_df.copy()
    user_point['species_name'] = 'NUEVA MUESTRA'
    # para graficar el punto nuevo junto con los viejos
    combined_df = pd.concat([df, user_point], ignore_index=True)

    fig_3d = px.scatter_3d(combined_df,
        x='sepal length (cm)', y='sepal width (cm)', z='petal length (cm)',
        color='species_name', size='petal width (cm)', size_max=18, opacity=0.7,
        title="Posici√≥n Espacial")
    st.plotly_chart(fig_3d, use_container_width=True)

import time
import sys
import os
import re

# 1. Limpieza de terreno
print("üßπ Limpiando procesos viejos...")
!pkill -f streamlit
!pkill -f cloudflared
if os.path.exists('tunnel.log'):
    os.remove('tunnel.log') # Borramos el rastro anterior

# 2. Arrancar la maquinaria
print("üöÄ Arrancando el servidor... (Esp√©rate un momentico)")
!nohup streamlit run Proyect.py > streamlit.log 2>&1 &
!nohup ./cloudflared-linux-amd64 tunnel --url http://localhost:8501 > tunnel.log 2>&1 &

# 3. Buscamos el link activamente
print("‚è≥ Buscando el link de acceso...")
found_link = None
for i in range(30): # Le damos 30 segundos m√°ximo
    time.sleep(2)
    if os.path.exists('tunnel.log'):
        with open('tunnel.log', 'r') as f:
            content = f.read()
            # Buscamos el patr√≥n del link con Regex
            match = re.search(r'https://[a-zA-Z0-9-]+\.trycloudflare\.com', content)
            if match:
                found_link = match.group(0)
                break

if found_link:
    print("\n" + "="*50)
    print(" ¬°CORONAMOS! DALE CLIC AL LINK DE ABAJO:")
    print(f"  {found_link}  ")
    print("="*50 + "\n")
else:
    print("\n‚ùå Eche, no apareci√≥ el link. Revisa si el archivo Proyect.py s√≠ existe en la carpeta.")

# 4. Mantener vivo el servidor
while True:
    time.sleep(10)